// This file was generated by `crates/core/src/bin/generate_types.rs`.

// Do not edit this file manually.

// If you are an AI, and you absolutely have to edit this file, please confirm with the user first.

export type DirectoryEntry = { name: string, path: string, is_directory: boolean, is_git_repo: boolean, last_modified: bigint | null, };

export type DirectoryListResponse = { entries: Array<DirectoryEntry>, current_path: string, };

export type Project = { id: string, name: string, git_repo_path: string, setup_script: string | null, dev_script: string | null, cleanup_script: string | null, copy_files: string | null, created_at: Date, updated_at: Date, };

export type ProjectWithBranch = { id: string, name: string, git_repo_path: string, setup_script: string | null, dev_script: string | null, cleanup_script: string | null, copy_files: string | null, current_branch: string | null, created_at: Date, updated_at: Date, };

export type CreateProject = { name: string, git_repo_path: string, use_existing_repo: boolean, setup_script: string | null, dev_script: string | null, cleanup_script: string | null, copy_files: string | null, };

export type UpdateProject = { name: string | null, git_repo_path: string | null, setup_script: string | null, dev_script: string | null, cleanup_script: string | null, copy_files: string | null, };

export type SearchResult = { path: string, is_file: boolean, match_type: SearchMatchType, };

export type SearchMatchType = "FileName" | "DirectoryName" | "FullPath";

export type SearchMode = "taskform" | "settings";

export type ExecutorAction = { typ: ExecutorActionType, next_action: ExecutorAction | null, };

export type McpConfig = { servers: { [key in string]?: JsonValue }, servers_path: Array<string>, template: JsonValue, vibe_kanban: JsonValue, is_toml_config: boolean, };

export type ExecutorActionType = { "type": "CodingAgentInitialRequest" } & CodingAgentInitialRequest | { "type": "CodingAgentFollowUpRequest" } & CodingAgentFollowUpRequest | { "type": "ScriptRequest" } & ScriptRequest;

export type ScriptContext = "SetupScript" | "CleanupScript" | "DevServer";

export type ScriptRequest = { script: string, language: ScriptRequestLanguage, context: ScriptContext, };

export type ScriptRequestLanguage = "Bash";

export enum BaseCodingAgent { CLAUDE_CODE = "CLAUDE_CODE", AMP = "AMP", GEMINI = "GEMINI", CODEX = "CODEX", OPENCODE = "OPENCODE", CURSOR = "CURSOR", QWEN_CODE = "QWEN_CODE", WARP_CLI = "WARP_CLI" }

export type CodingAgent = { "CLAUDE_CODE": ClaudeCode } | { "AMP": Amp } | { "GEMINI": Gemini } | { "CODEX": Codex } | { "OPENCODE": Opencode } | { "CURSOR": Cursor } | { "QWEN_CODE": QwenCode } | { "WARP_CLI": WarpCli };

export type TaskTemplate = { id: string, project_id: string | null, title: string, description: string | null, template_name: string, created_at: string, updated_at: string, };

export type CreateTaskTemplate = { project_id: string | null, title: string, description: string | null, template_name: string, };

export type UpdateTaskTemplate = { title: string | null, description: string | null, template_name: string | null, };

export type TaskStatus = "todo" | "inprogress" | "inreview" | "done" | "cancelled";

export type Task = { id: string, project_id: string, title: string, description: string | null, status: TaskStatus, parent_task_attempt: string | null, created_at: string, updated_at: string, };

export type TaskWithAttemptStatus = { id: string, project_id: string, title: string, description: string | null, status: TaskStatus, parent_task_attempt: string | null, created_at: string, updated_at: string, has_in_progress_attempt: boolean, has_merged_attempt: boolean, last_attempt_failed: boolean, executor: string, };

export type CreateTask = { project_id: string, title: string, description: string | null, parent_task_attempt: string | null, image_ids: Array<string> | null, };

export type UpdateTask = { title: string | null, description: string | null, status: TaskStatus | null, parent_task_attempt: string | null, image_ids: Array<string> | null, };

export type Image = { id: string, file_path: string, original_name: string, mime_type: string | null, size_bytes: bigint, hash: string, created_at: string, updated_at: string, };

export type CreateImage = { file_path: string, original_name: string, mime_type: string | null, size_bytes: bigint, hash: string, };

export type ApiResponse<T, E = T> = { success: boolean, data: T | null, error_data: E | null, message: string | null, };

export type UserSystemInfo = { config: Config, environment: Environment, 
/**
 * Capabilities supported per executor (e.g., { "CLAUDE_CODE": ["RESTORE_CHECKPOINT"] })
 */
capabilities: { [key in string]?: Array<BaseAgentCapability> }, executors: { [key in BaseCodingAgent]?: ExecutorConfig }, };

export type Environment = { os_type: string, os_version: string, os_architecture: string, bitness: string, };

export type McpServerQuery = { executor: BaseCodingAgent, };

export type UpdateMcpServersBody = { servers: { [key in string]?: JsonValue }, };

export type GetMcpServerResponse = { mcp_config: McpConfig, config_path: string, };

export type CreateFollowUpAttempt = { prompt: string, variant: string | null, image_ids: Array<string> | null, };

export type CreateGitHubPrRequest = { title: string, body: string | null, base_branch: string | null, };

export type ImageResponse = { id: string, file_path: string, original_name: string, mime_type: string | null, size_bytes: bigint, hash: string, created_at: string, updated_at: string, };

export enum GitHubServiceError { TOKEN_INVALID = "TOKEN_INVALID", INSUFFICIENT_PERMISSIONS = "INSUFFICIENT_PERMISSIONS", REPO_NOT_FOUND_OR_NO_ACCESS = "REPO_NOT_FOUND_OR_NO_ACCESS" }

export type Config = { config_version: string, theme: ThemeMode, executor_profile: ExecutorProfileId, disclaimer_acknowledged: boolean, onboarding_acknowledged: boolean, github_login_acknowledged: boolean, telemetry_acknowledged: boolean, notifications: NotificationConfig, editor: EditorConfig, github: GitHubConfig, analytics_enabled: boolean | null, workspace_dir: string | null, last_app_version: string | null, show_release_notes: boolean, };

export type NotificationConfig = { sound_enabled: boolean, push_enabled: boolean, sound_file: SoundFile, };

export enum ThemeMode { LIGHT = "LIGHT", DARK = "DARK", SYSTEM = "SYSTEM", PURPLE = "PURPLE", GREEN = "GREEN", BLUE = "BLUE", ORANGE = "ORANGE", RED = "RED" }

export type EditorConfig = { editor_type: EditorType, custom_command: string | null, };

export enum EditorType { VS_CODE = "VS_CODE", CURSOR = "CURSOR", WINDSURF = "WINDSURF", INTELLI_J = "INTELLI_J", ZED = "ZED", XCODE = "XCODE", CUSTOM = "CUSTOM" }

export type GitHubConfig = { pat: string | null, oauth_token: string | null, username: string | null, primary_email: string | null, default_pr_base: string | null, };

export enum SoundFile { ABSTRACT_SOUND1 = "ABSTRACT_SOUND1", ABSTRACT_SOUND2 = "ABSTRACT_SOUND2", ABSTRACT_SOUND3 = "ABSTRACT_SOUND3", ABSTRACT_SOUND4 = "ABSTRACT_SOUND4", COW_MOOING = "COW_MOOING", PHONE_VIBRATION = "PHONE_VIBRATION", ROOSTER = "ROOSTER" }

export type DeviceFlowStartResponse = { user_code: string, verification_uri: string, expires_in: number, interval: number, };

export enum DevicePollStatus { SLOW_DOWN = "SLOW_DOWN", AUTHORIZATION_PENDING = "AUTHORIZATION_PENDING", SUCCESS = "SUCCESS" }

export enum CheckTokenResponse { VALID = "VALID", INVALID = "INVALID" }

export type GitBranch = { name: string, is_current: boolean, is_remote: boolean, last_commit_date: Date, };

export type Diff = { change: DiffChangeKind, oldPath: string | null, newPath: string | null, oldContent: string | null, newContent: string | null, };

export type DiffChangeKind = "added" | "deleted" | "modified" | "renamed" | "copied" | "permissionChange";

export type FileDiffDetails = { fileName: string | null, content: string | null, };

export type RepositoryInfo = { id: bigint, name: string, full_name: string, owner: string, description: string | null, clone_url: string, ssh_url: string, default_branch: string, private: boolean, };

export type CommandBuilder = { 
/**
 * Base executable command (e.g., "npx -y @anthropic-ai/claude-code@latest")
 */
base: string, 
/**
 * Optional parameters to append to the base command
 */
params: Array<string> | null, };

export type ExecutorProfileId = { 
/**
 * The executor type (e.g., "CLAUDE_CODE", "AMP")
 */
executor: BaseCodingAgent, 
/**
 * Optional variant name (e.g., "PLAN", "ROUTER")
 */
variant: string | null, };

export type ExecutorConfig = { [key in string]?: { "CLAUDE_CODE": ClaudeCode } | { "AMP": Amp } | { "GEMINI": Gemini } | { "CODEX": Codex } | { "OPENCODE": Opencode } | { "CURSOR": Cursor } | { "QWEN_CODE": QwenCode } | { "WARP_CLI": WarpCli } };

export type BaseAgentCapability = "RESTORE_CHECKPOINT";

export type ClaudeCode = { append_prompt: AppendPrompt, claude_code_router?: boolean | null, plan?: boolean | null, dangerously_skip_permissions?: boolean | null, base_command_override?: string | null, additional_params?: Array<string> | null, };

export type Gemini = { append_prompt: AppendPrompt, model: GeminiModel, yolo?: boolean | null, base_command_override?: string | null, additional_params?: Array<string> | null, };

export type GeminiModel = "default" | "flash";

export type Amp = { append_prompt: AppendPrompt, dangerously_allow_all?: boolean | null, base_command_override?: string | null, additional_params?: Array<string> | null, };

export type Codex = { append_prompt: AppendPrompt, sandbox?: SandboxMode | null, approval?: ApprovalPolicy | null, oss?: boolean | null, model?: string | null, base_command_override?: string | null, additional_params?: Array<string> | null, };

export type SandboxMode = "read-only" | "workspace-write" | "danger-full-access";

export type ApprovalPolicy = "untrusted" | "on-failure" | "on-request" | "never";

export type Cursor = { append_prompt: AppendPrompt, force?: boolean | null, model?: string | null, base_command_override?: string | null, additional_params?: Array<string> | null, };

export type Opencode = { append_prompt: AppendPrompt, model?: string | null, agent?: string | null, base_command_override?: string | null, additional_params?: Array<string> | null, };

export type QwenCode = { append_prompt: AppendPrompt, yolo?: boolean | null, base_command_override?: string | null, additional_params?: Array<string> | null, };

export type WarpCli = { append_prompt: AppendPrompt, profile?: string | null, mcp_servers?: Array<string>, extra_flags?: Array<string>, binary?: string | null, base_command_override?: string | null, additional_params?: Array<string> | null, };

export type AppendPrompt = string | null;

export type CodingAgentInitialRequest = { prompt: string, 
/**
 * Executor profile specification
 */
executor_profile_id: ExecutorProfileId, };

export type CodingAgentFollowUpRequest = { prompt: string, session_id: string, 
/**
 * Executor profile specification
 */
executor_profile_id: ExecutorProfileId, };

export type CreateTaskAttemptBody = { task_id: string, 
/**
 * Executor profile specification
 */
executor_profile_id: ExecutorProfileId, base_branch: string, };

export type RebaseTaskAttemptRequest = { new_base_branch: string | null, };

export type RestoreAttemptRequest = { 
/**
 * Process to restore to (target = its after_head_commit)
 */
process_id: string, 
/**
 * If true, allow resetting Git even when uncommitted changes exist
 */
force_when_dirty: boolean | null, 
/**
 * If false, skip performing the Git reset step (history drop still applies)
 */
perform_git_reset: boolean | null, };

export type RestoreAttemptResult = { had_later_processes: boolean, git_reset_needed: boolean, git_reset_applied: boolean, target_after_oid: string | null, };

export type CommitInfo = { sha: string, subject: string, };

export type CommitCompareResult = { head_oid: string, target_oid: string, ahead_from_head: number, behind_from_head: number, is_linear: boolean, };

export type BranchStatus = { commits_behind: number | null, commits_ahead: number | null, has_uncommitted_changes: boolean | null, head_oid: string | null, uncommitted_count: number | null, untracked_count: number | null, base_branch_name: string, remote_commits_behind: number | null, remote_commits_ahead: number | null, merges: Array<Merge>, };

export type TaskAttempt = { id: string, task_id: string, container_ref: string | null, branch: string | null, base_branch: string, executor: string, worktree_deleted: boolean, setup_completed_at: string | null, created_at: string, updated_at: string, };

export type ExecutionProcess = { id: string, task_attempt_id: string, run_reason: ExecutionProcessRunReason, executor_action: ExecutorAction, 
/**
 * Git HEAD commit OID captured after the process ends
 */
after_head_commit: string | null, status: ExecutionProcessStatus, exit_code: bigint | null, 
/**
 * dropped: true if this process is excluded from the current
 * history view (due to restore/trimming). Hidden from logs/timeline;
 * still listed in the Processes tab.
 */
dropped: boolean, started_at: string, completed_at: string | null, created_at: string, updated_at: string, };

export type ExecutionProcessStatus = "running" | "completed" | "failed" | "killed";

export type ExecutionProcessRunReason = "setupscript" | "cleanupscript" | "codingagent" | "devserver";

export type Merge = { "type": "direct" } & DirectMerge | { "type": "pr" } & PrMerge;

export type DirectMerge = { id: string, task_attempt_id: string, merge_commit: string, target_branch_name: string, created_at: string, };

export type PrMerge = { id: string, task_attempt_id: string, created_at: string, target_branch_name: string, pr_info: PullRequestInfo, };

export type MergeStatus = "open" | "merged" | "closed" | "unknown";

export type PullRequestInfo = { number: bigint, url: string, status: MergeStatus, merged_at: string | null, merge_commit_sha: string | null, };

export type EventPatch = { op: string, path: string, value: EventPatchInner, };

export type EventPatchInner = { db_op: string, record: RecordTypes, };

export type RecordTypes = { "type": "TASK", "data": Task } | { "type": "TASK_ATTEMPT", "data": TaskAttempt } | { "type": "EXECUTION_PROCESS", "data": ExecutionProcess } | { "type": "DELETED_TASK", "data": { rowid: bigint, project_id: string | null, task_id: string | null, } } | { "type": "DELETED_TASK_ATTEMPT", "data": { rowid: bigint, task_id: string | null, } } | { "type": "DELETED_EXECUTION_PROCESS", "data": { rowid: bigint, task_attempt_id: string | null, } };

export type CommandExitStatus = { "type": "exit_code", code: number, } | { "type": "success", success: boolean, };

export type CommandRunResult = { exit_status: CommandExitStatus | null, output: string | null, };

export type NormalizedConversation = { entries: Array<NormalizedEntry>, session_id: string | null, executor_type: string, prompt: string | null, summary: string | null, };

export type NormalizedEntry = { timestamp: string | null, entry_type: NormalizedEntryType, content: string, };

export type NormalizedEntryType = { "type": "user_message" } | { "type": "assistant_message" } | { "type": "tool_use", tool_name: string, action_type: ActionType, } | { "type": "system_message" } | { "type": "error_message" } | { "type": "thinking" };

export type FileChange = { "action": "write", content: string, } | { "action": "delete" } | { "action": "rename", new_path: string, } | { "action": "edit", 
/**
 * Unified diff containing file header and hunks.
 */
unified_diff: string, 
/**
 * Whether line number in the hunks are reliable.
 */
has_line_numbers: boolean, };

export type ActionType = { "action": "file_read", path: string, } | { "action": "file_edit", path: string, changes: Array<FileChange>, } | { "action": "command_run", command: string, result: CommandRunResult | null, } | { "action": "search", query: string, } | { "action": "web_fetch", url: string, } | { "action": "tool", tool_name: string, arguments: JsonValue | null, result: ToolResult | null, } | { "action": "task_create", description: string, } | { "action": "plan_presentation", plan: string, } | { "action": "todo_management", todos: Array<TodoItem>, operation: string, } | { "action": "other", description: string, };

export type TodoItem = { content: string, status: string, priority: string | null, };

export type ToolResult = { type: ToolResultValueType, 
/**
 * For Markdown, this will be a JSON string; for JSON, a structured value
 */
value: JsonValue, };

export type ToolResultValueType = { "type": "markdown" } | { "type": "json" };

export type PatchType = { "type": "NORMALIZED_ENTRY", "content": NormalizedEntry } | { "type": "STDOUT", "content": string } | { "type": "STDERR", "content": string } | { "type": "DIFF", "content": Diff };

export type JsonValue = number | string | boolean | Array<JsonValue> | { [key in string]?: JsonValue } | null;