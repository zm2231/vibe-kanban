use std::{env, fs, path::Path};

use schemars::{JsonSchema, Schema, SchemaGenerator, generate::SchemaSettings};
use ts_rs::TS;

fn generate_types_content() -> String {
    // 4. Friendly banner
    const HEADER: &str = "// This file was generated by `crates/core/src/bin/generate_types.rs`.\n
// Do not edit this file manually.\n
// If you are an AI, and you absolutely have to edit this file, please confirm with the user first.";

    let decls: Vec<String> = vec![
        services::services::filesystem::DirectoryEntry::decl(),
        services::services::filesystem::DirectoryListResponse::decl(),
        db::models::project::Project::decl(),
        db::models::project::ProjectWithBranch::decl(),
        db::models::project::CreateProject::decl(),
        db::models::project::UpdateProject::decl(),
        db::models::project::SearchResult::decl(),
        db::models::project::SearchMatchType::decl(),
        services::services::file_search_cache::SearchMode::decl(),
        executors::actions::ExecutorAction::decl(),
        executors::mcp_config::McpConfig::decl(),
        executors::actions::ExecutorActionType::decl(),
        executors::actions::script::ScriptContext::decl(),
        executors::actions::script::ScriptRequest::decl(),
        executors::actions::script::ScriptRequestLanguage::decl(),
        executors::executors::BaseCodingAgent::decl(),
        executors::executors::CodingAgent::decl(),
        db::models::task_template::TaskTemplate::decl(),
        db::models::task_template::CreateTaskTemplate::decl(),
        db::models::task_template::UpdateTaskTemplate::decl(),
        db::models::task::TaskStatus::decl(),
        db::models::task::Task::decl(),
        db::models::task::TaskWithAttemptStatus::decl(),
        db::models::task::CreateTask::decl(),
        db::models::task::UpdateTask::decl(),
        db::models::image::Image::decl(),
        db::models::image::CreateImage::decl(),
        utils::response::ApiResponse::<()>::decl(),
        server::routes::config::UserSystemInfo::decl(),
        server::routes::config::Environment::decl(),
        server::routes::config::McpServerQuery::decl(),
        server::routes::config::UpdateMcpServersBody::decl(),
        server::routes::config::GetMcpServerResponse::decl(),
        server::routes::task_attempts::CreateFollowUpAttempt::decl(),
        server::routes::task_attempts::CreateGitHubPrRequest::decl(),
        server::routes::images::ImageResponse::decl(),
        services::services::github_service::GitHubServiceError::decl(),
        services::services::config::Config::decl(),
        services::services::config::NotificationConfig::decl(),
        services::services::config::ThemeMode::decl(),
        services::services::config::EditorConfig::decl(),
        services::services::config::EditorType::decl(),
        services::services::config::GitHubConfig::decl(),
        services::services::config::SoundFile::decl(),
        services::services::auth::DeviceFlowStartResponse::decl(),
        server::routes::auth::DevicePollStatus::decl(),
        server::routes::auth::CheckTokenResponse::decl(),
        services::services::git::GitBranch::decl(),
        utils::diff::Diff::decl(),
        utils::diff::DiffChangeKind::decl(),
        utils::diff::FileDiffDetails::decl(),
        services::services::github_service::RepositoryInfo::decl(),
        executors::command::CommandBuilder::decl(),
        executors::profile::ExecutorProfileId::decl(),
        executors::profile::ExecutorConfig::decl(),
        executors::executors::BaseAgentCapability::decl(),
        executors::executors::claude::ClaudeCode::decl(),
        executors::executors::gemini::Gemini::decl(),
        executors::executors::gemini::GeminiModel::decl(),
        executors::executors::amp::Amp::decl(),
        executors::executors::codex::Codex::decl(),
        executors::executors::codex::SandboxMode::decl(),
        executors::executors::codex::ApprovalPolicy::decl(),
        executors::executors::cursor::Cursor::decl(),
        executors::executors::opencode::Opencode::decl(),
        executors::executors::qwen::QwenCode::decl(),
        executors::executors::warp_cli::WarpCli::decl(),
        executors::executors::AppendPrompt::decl(),
        executors::actions::coding_agent_initial::CodingAgentInitialRequest::decl(),
        executors::actions::coding_agent_follow_up::CodingAgentFollowUpRequest::decl(),
        server::routes::task_attempts::CreateTaskAttemptBody::decl(),
        server::routes::task_attempts::RebaseTaskAttemptRequest::decl(),
        server::routes::task_attempts::RestoreAttemptRequest::decl(),
        server::routes::task_attempts::RestoreAttemptResult::decl(),
        server::routes::task_attempts::CommitInfo::decl(),
        server::routes::task_attempts::CommitCompareResult::decl(),
        server::routes::task_attempts::BranchStatus::decl(),
        db::models::task_attempt::TaskAttempt::decl(),
        db::models::execution_process::ExecutionProcess::decl(),
        db::models::execution_process::ExecutionProcessStatus::decl(),
        db::models::execution_process::ExecutionProcessRunReason::decl(),
        db::models::merge::Merge::decl(),
        db::models::merge::DirectMerge::decl(),
        db::models::merge::PrMerge::decl(),
        db::models::merge::MergeStatus::decl(),
        db::models::merge::PullRequestInfo::decl(),
        services::services::events::EventPatch::decl(),
        services::services::events::EventPatchInner::decl(),
        services::services::events::RecordTypes::decl(),
        executors::logs::CommandExitStatus::decl(),
        executors::logs::CommandRunResult::decl(),
        executors::logs::NormalizedConversation::decl(),
        executors::logs::NormalizedEntry::decl(),
        executors::logs::NormalizedEntryType::decl(),
        executors::logs::FileChange::decl(),
        executors::logs::ActionType::decl(),
        executors::logs::TodoItem::decl(),
        executors::logs::ToolResult::decl(),
        executors::logs::ToolResultValueType::decl(),
        executors::logs::utils::patch::PatchType::decl(),
        serde_json::Value::decl(),
    ];

    let body = decls
        .into_iter()
        .map(|d| {
            let trimmed = d.trim_start();
            if trimmed.starts_with("export") {
                d
            } else {
                format!("export {trimmed}")
            }
        })
        .collect::<Vec<_>>()
        .join("\n\n");

    format!("{HEADER}\n\n{body}")
}

fn write_schema<T: JsonSchema>(
    name: &str,
    schemas_dir: &std::path::Path,
) -> Result<(), Box<dyn std::error::Error>> {
    // Draft-07, inline everything (no $defs)
    let mut settings = SchemaSettings::draft07();
    settings.inline_subschemas = true;

    let generator: SchemaGenerator = settings.into_generator();
    let schema: Schema = generator.into_root_schema_for::<T>();

    // Convert to JSON value to manipulate it
    let mut schema_value: serde_json::Value = serde_json::to_value(&schema)?;

    // Remove the title from root schema to prevent RJSF from creating an outer field container
    if let Some(obj) = schema_value.as_object_mut() {
        obj.remove("title");
    }

    let schema_json = serde_json::to_string_pretty(&schema_value)?;
    std::fs::write(schemas_dir.join(format!("{name}.json")), schema_json)?;
    Ok(())
}

fn generate_schemas() -> Result<(), Box<dyn std::error::Error>> {
    // Create schemas directory
    let schemas_dir = Path::new("shared/schemas");
    fs::create_dir_all(schemas_dir)?;

    println!("Generating JSON schemas…");

    // Generate schemas for all executor types
    write_schema::<executors::executors::amp::Amp>("amp", schemas_dir)?;
    write_schema::<executors::executors::claude::ClaudeCode>("claude_code", schemas_dir)?;
    write_schema::<executors::executors::gemini::Gemini>("gemini", schemas_dir)?;
    write_schema::<executors::executors::codex::Codex>("codex", schemas_dir)?;
    write_schema::<executors::executors::cursor::Cursor>("cursor", schemas_dir)?;
    write_schema::<executors::executors::opencode::Opencode>("opencode", schemas_dir)?;
    write_schema::<executors::executors::qwen::QwenCode>("qwen_code", schemas_dir)?;
    write_schema::<executors::executors::warp_cli::WarpCli>("warp_cli", schemas_dir)?;

    Ok(())
}

fn main() {
    let args: Vec<String> = env::args().collect();
    let check_mode = args.iter().any(|arg| arg == "--check");

    let shared_path = Path::new("shared");

    println!("Generating TypeScript types…");

    let generated = generate_types_content();
    let types_path = shared_path.join("types.ts");

    if check_mode {
        // Read the current file
        let current = fs::read_to_string(&types_path).unwrap_or_default();
        if current == generated {
            println!("✅ shared/types.ts is up to date.");
            std::process::exit(0);
        } else {
            eprintln!(
                "❌ shared/types.ts is not up to date. Please run 'npm run generate-types' and commit the changes."
            );
            std::process::exit(1);
        }
    } else {
        // Wipe existing shared
        fs::remove_dir_all(shared_path).ok();

        // Recreate folder
        fs::create_dir_all(shared_path).expect("cannot create shared");

        // Write the file as before
        fs::write(&types_path, generated).expect("unable to write types.ts");
        println!("✅ TypeScript types generated in shared/");

        // Generate JSON schemas
        if let Err(e) = generate_schemas() {
            eprintln!("❌ Failed to generate schemas: {}", e);
            std::process::exit(1);
        }

        println!("✅ JSON schemas generated in shared/schemas/");
    }
}
